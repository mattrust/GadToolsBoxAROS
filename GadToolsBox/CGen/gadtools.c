/*
** Source code generated by GadToolsBox 0.0 (c) by Tomasz Muszynski
** GUI designed by: Tomasz Muszynski
*/

#include<stdio.h>
#include<proto/exec.h>
#include<exec/memory.h>
#include<proto/gadtools.h>
#include<proto/graphics.h>
#include<intuition/pointerclass.h>
#include<intuition/imageclass.h>
#include<libraries/iffparse.h>
#include<proto/locale.h>
#include<proto/intuition.h>
#include<proto/utility.h>
#include<intuition/gadgetclass.h>
#include"gadtools.h"
#include"gadtools_cat.h"

TEXT VER_STRING[]=VER_SVER;

struct Screen *Scr=NULL;
struct DrawInfo *DrawInfo=NULL;
APTR VisualInfo=NULL;
TEXT ScrTitle[256];
TEXT ScrPubName[30];
struct Catalog *Catalog=NULL;
struct Locale *Locale=NULL;
struct TextAttr *Font, Attr;
UWORD FontX, FontY;
BOOL GadgetLocaleDone[CNTWND_WINDOWS];
BOOL WindowLocaleDone[CNTWND_WINDOWS];
BOOL MenuLocaleDone[CNTMN_MENUS];


/* Prefs Window structures */
struct Window *PrefsWnd=NULL;
struct Gadget *PrefsGList=NULL;
struct Gadget *PrefsGadgets[CNT_Prefs];
struct IntuiMessage PrefsMsg;


/* Prefs Window tags */
ULONG PrefsWTags[]=
{
	WA_CenterX, TRUE, WA_CenterY, TRUE, WA_Width, 281, WA_Height, 139, WA_Title, (ULONG) MSG_Prefs_WND, WA_IDCMP, IDCMP_CLOSEWINDOW|IDCMP_GADGETDOWN|IDCMP_GADGETUP|BUTTONIDCMP|CHECKBOXIDCMP, WA_Flags, WFLG_DRAGBAR|WFLG_DEPTHGADGET|WFLG_SIMPLE_REFRESH|WFLG_ACTIVATE|WFLG_NEWLOOKMENUS, WA_RMBTrap, TRUE, WA_FontAdaptive, TRUE, TAG_DONE
};

/* Prefs Gadget structures */

/* Prefs Gadget tags */
ULONG PrefsGTags[]=
{
	CHECKBOX_KIND, PLACETEXT_LEFT, GT_Underscore, '_', GTCB_Scaled, TRUE, GA_Text, (ULONG) MSG_TEMPLATE_GAD, GA_Left, 160, GA_Top, 4, GA_Width, 25, GA_Height, 17, GA_UserData, (ULONG) FN_TEMPLATE_Clicked, TAG_DONE,
	CHECKBOX_KIND, PLACETEXT_LEFT, GT_Underscore, '_', GTCB_Scaled, TRUE, GA_Text, (ULONG) MSG_GUIFUNCS_GAD, GA_Left, 160, GA_Top, 44, GA_Width, 25, GA_Height, 17, GA_UserData, (ULONG) FN_GUIFUNCS_Clicked, TAG_DONE,
	CHECKBOX_KIND, PLACETEXT_LEFT, GT_Underscore, '_', GTCB_Scaled, TRUE, GA_Text, (ULONG) MSG_LOCALIZE_GAD, GA_Left, 160, GA_Top, 64, GA_Width, 25, GA_Height, 17, GA_UserData, (ULONG) FN_LOCALIZE_Clicked, TAG_DONE,
	BUTTON_KIND, PLACETEXT_IN, GT_Underscore, '_', GA_ToggleSelect, FALSE, GA_Text, (ULONG) MSG_SAVE_GAD, GA_Left, 8, GA_Top, 96, GA_Width, 81, GA_Height, 17, GA_UserData, (ULONG) FN_SAVE_Clicked, TAG_DONE,
	BUTTON_KIND, PLACETEXT_IN, GT_Underscore, '_', GA_ToggleSelect, FALSE, GA_Text, (ULONG) MSG_CANCEL_GAD, GA_Left, 184, GA_Top, 96, GA_Width, 81, GA_Height, 17, GA_UserData, (ULONG) FN_CANCEL_Clicked, TAG_DONE,
	BUTTON_KIND, PLACETEXT_IN, GT_Underscore, '_', GA_ToggleSelect, FALSE, GA_Text, (ULONG) MSG_USE_GAD, GA_Left, 96, GA_Top, 96, GA_Width, 81, GA_Height, 17, GA_UserData, (ULONG) FN_USE_Clicked, TAG_DONE,
	CHECKBOX_KIND, PLACETEXT_LEFT, GT_Underscore, '_', GTCB_Scaled, TRUE, GA_Text, (ULONG) MSG_SCREEN_GAD, GA_Left, 160, GA_Top, 24, GA_Width, 25, GA_Height, 17, GA_UserData, (ULONG) FN_SCREEN_Clicked, TAG_DONE
};

/* Application functions */

UWORD InitApplication(STRPTR language)
{
	if(!(Locale=OpenLocale(NULL))) return GTBERR_LOCALE;
	Catalog=OpenCatalog(Locale,"c.generator.catalog",
			OC_BuiltInLanguage,"english", OC_Version, VER_VERSION,
			language?OC_Language:TAG_IGNORE, language, TAG_DONE);
	return GTBERR_OK;
}

void FreeApplication()
{
	if(Catalog) CloseCatalog(Catalog); Catalog=NULL;
}

STRPTR GetCatString(APTR fcstr)
{
	STRPTR defaultstr;
	LONG strnum;

	strnum=((struct FC_Type *)fcstr)->ID;
	defaultstr=((struct FC_Type *)fcstr)->Str;

	return(Catalog ? GetCatalogStr(Catalog,strnum,defaultstr) : defaultstr);
}

struct Gadget *CreateGadgetExA(UWORD offx,UWORD offy,UWORD offr,UWORD offb,struct Gadget *prev,struct TagItem *tags)
{
	struct Gadget *g;
	struct NewGadget ng;
	ULONG kind,flags,x,y,w,h;
	BOOL rx=0,ry=0,rw=0,rh=0;
	struct TagItem *ti;
	
	kind=tags[0].ti_Tag;
	flags=tags[0].ti_Data;
	tags=&tags[1];

	if(ti=FindTagItem(GA_Left,tags)) x=AdaptX(ti->ti_Data)+offx;
	else { x=AdaptX(GetTagData(GA_RelRight,0,tags))-offr; rx=TRUE; }

	if(ti=FindTagItem(GA_Top,tags)) y=AdaptY(ti->ti_Data)+offy;
	else { y=AdaptY(GetTagData(GA_RelBottom,0,tags))-offb; ry=TRUE; }

	if(ti=FindTagItem(GA_Width,tags)) w=AdaptX(ti->ti_Data);
	else { w=AdaptX(GetTagData(GA_RelWidth,0,tags))-x-offr; rw=TRUE; }

	if(ti=FindTagItem(GA_Height,tags)) h=AdaptY(ti->ti_Data);
	else { h=AdaptY(GetTagData(GA_RelHeight,0,tags))-y-offb; rh=TRUE; }

	switch(kind)
	{
		case BUTTON_KIND:
		case CHECKBOX_KIND:
		case INTEGER_KIND:
		case LISTVIEW_KIND:
		case MX_KIND:
		case NUMBER_KIND:
		case CYCLE_KIND:
		case PALETTE_KIND:
		case SCROLLER_KIND:
		case SLIDER_KIND:
		case STRING_KIND:
		case TEXT_KIND:
			ng.ng_LeftEdge=x;
			ng.ng_TopEdge=y;
			ng.ng_Width=w;
			ng.ng_Height=h;
			ng.ng_Flags=flags;
			ng.ng_UserData=(APTR)GetTagData(GA_UserData,0,tags);
			ng.ng_GadgetID=GetTagData(GA_ID,0,tags);
			ng.ng_GadgetText=(char *)GetTagData(GA_Text,0,tags);
			ng.ng_VisualInfo=VisualInfo;
			ng.ng_TextAttr=Font;
			g=CreateGadgetA(kind,prev,&ng,tags);
			if(!g) return g;
			if(GetTagData(GA_ToggleSelect,0,tags)) g->Activation|=GACT_TOGGLESELECT;
			if(rx) g->Flags|=GFLG_RELRIGHT;
			if(ry) g->Flags|=GFLG_RELBOTTOM;
			if(rw) g->Flags|=GFLG_RELWIDTH;
			if(rh) g->Flags|=GFLG_RELHEIGHT;
			break;
	}
	return g;
}

void DeleteGadgetExA(struct Gadget *g,struct TagItem *tags)
{
	switch(tags[0].ti_Tag)
	{
		case COLORWHEEL_KIND:
		case GRADIENTSLIDER_KIND:
		case PAGE_KIND:
		case POPUPMENU_KIND:
		case PROGRESS_KIND:
		case TAPEDECK_KIND:
		case TEXTFIELD_KIND:
		case TREEVIEW_KIND:
			DisposeObject(g);
			break;
		case TOOLIMAGE_KIND:
			g->GadgetRender=g->SelectRender=NULL;
			break;
	}
}

struct Window *OpenWindowTagsEx(ULONG tags,...)
{
	struct Gadget *g=NULL;
	struct Window *win;
	struct TagItem *ti,*clone=NULL;
	BOOL tbg=FALSE,rx=FALSE,ry=FALSE,rw=FALSE,rh=FALSE;
	ULONG left,top,width,height;

	clone=CloneTagItems((struct TagItem *)&tags);
	if(ti=FindTagItem(WA_ToolDragBar,clone))
	{
		if(g=AllocMem(sizeof(struct Gadget),MEMF_ANY|MEMF_CLEAR))
		{
			g->LeftEdge=0;
			g->TopEdge=0;
			g->Flags=GFLG_GADGHNONE;
			g->GadgetType=GTYP_WDRAGGING;
			g->UserData=(APTR)DRAG_ID;
			if(ti->ti_Data==TOOL_HORIZ)
			{
				g->Activation=GACT_TOPBORDER|GACT_BORDERSNIFF;
				g->Width=32767;
				g->Height=8;
			}
			else
			{
				g->Activation=GACT_LEFTBORDER|GACT_BORDERSNIFF;
				g->Width=8;
				g->Height=32767;
			}
		}
		else return NULL;
		ti->ti_Tag=TAG_IGNORE;
	}

	if(ti=FindTagItem(WA_RelWidth,clone))
	{
		rw=TRUE;
		width=(Scr->Width)-ti->ti_Data;
		ti->ti_Tag=TAG_IGNORE;
	}
	if(ti=FindTagItem(WA_RelHeight,clone))
	{
		rh=TRUE;
		height=(Scr->Height)-ti->ti_Data;
		ti->ti_Tag=TAG_IGNORE;
	}

	if(ti=FindTagItem(WA_CenterX,clone))
	{
		rx=TRUE;
		left=(Scr->Width/2)-(GetTagData(WA_Width,GetTagData(WA_InnerWidth,width,clone),clone)/2);
		ti->ti_Tag=TAG_IGNORE;
	}
	if(ti=FindTagItem(WA_CenterY,clone))
	{
		ry=TRUE;
		top=(Scr->Height/2)-(GetTagData(WA_Height,GetTagData(WA_InnerHeight,height,clone),clone)/2);
		ti->ti_Tag=TAG_IGNORE;
	}
	if(ti=FindTagItem(WA_RelRight,clone))
	{
		rx=TRUE;
		left=(Scr->Width)-(GetTagData(WA_Width,GetTagData(WA_InnerWidth,width,clone),clone))-ti->ti_Data;
		ti->ti_Tag=TAG_IGNORE;
	}
	if(ti=FindTagItem(WA_RelBottom,clone))
	{
		ry=TRUE;
		top=(Scr->Height)-(GetTagData(WA_Height,GetTagData(WA_InnerHeight,height,clone),clone))-ti->ti_Data;
		ti->ti_Tag=TAG_IGNORE;
	}

	if(ti=FindTagItem(WA_Gadgets,clone))
	{
		if(g)
		{
			g->NextGadget=(struct Gadget *)ti->ti_Data;
			ti->ti_Data=(ULONG)g;
			tbg=TRUE;
		}
		if(ti->ti_Data==NULL) ti->ti_Tag=TAG_IGNORE;
	}

	if(ti=FindTagItem(WA_FontAdaptive,clone))
	{
		width=AdaptX(width);
		height=AdaptY(height);
		ti->ti_Tag=TAG_IGNORE;
		if(ti=FindTagItem(WA_Width,clone)) ti->ti_Data=AdaptX(ti->ti_Data);
		if(ti=FindTagItem(WA_Height,clone)) ti->ti_Data=AdaptY(ti->ti_Data);
	}

	if(!(win=OpenWindowTags(NULL,
			rx?WA_Left:TAG_IGNORE,left,
			ry?WA_Top:TAG_IGNORE,top,
			rw?WA_Width:TAG_IGNORE,width,
			rh?WA_Height:TAG_IGNORE,height,
			TAG_MORE,(ULONG)clone)))
		if(g) FreeMem(win,sizeof(struct Gadget));

	if(clone) FreeTagItems(clone);
	return win;
}

void CloseWindowEx(struct Window *win)
{
	struct Gadget *g,*drag=NULL;

	g=win->FirstGadget;
	while(g)
	{
		if(((ULONG)g->UserData)==DRAG_ID) { drag=g; break; }
		g=g->NextGadget;
	}
	CloseWindow(win);
	if(drag) FreeMem(drag,sizeof(struct Gadget));
}

void CalcLeftTop(UWORD *offx,UWORD *offy,struct TagItem *tags)
{
	struct TagItem *ti;
	BOOL bl;

	*offx=0;
	*offy=0;

	if(ti=FindTagItem(WA_Borderless,tags))
		bl=ti->ti_Data;
	else
		bl=((GetTagData(WA_Flags,NULL,tags)&WFLG_BORDERLESS)?TRUE:FALSE);

	if(ti=FindTagItem(WA_ToolDragBar,tags))
	{
		if(ti->ti_Data==TOOL_HORIZ)
		{
			(*offy)+=8;
			if(!bl) (*offx)+=Scr->WBorLeft;
		}
		else
		{
			(*offx)+=8;
			if(!bl) (*offy)+=Scr->WBorTop;
		}
	}
	else
	{
		if(!bl)
		{
			(*offx)+=Scr->WBorLeft;
			if(GetTagData(WA_Title,NULL,tags))
				(*offy)+=Scr->WBorTop+Scr->RastPort.TxHeight+1;
			else
				(*offy)+=Scr->WBorTop;
		}
	}
}

void CalcRightBottom(UWORD *offx,UWORD *offy,struct TagItem *tags)
{
	struct TagItem *ti;
	BOOL bl,sg,sbb,sbr;
	UWORD sw,sh;
	struct Image *im;

	*offx=0;
	*offy=0;

	if(ti=FindTagItem(WA_Borderless,tags))
		bl=ti->ti_Data;
	else
		bl=(GetTagData(WA_Flags,NULL,tags)&WFLG_BORDERLESS);

	if(ti=FindTagItem(WA_SizeGadget,tags))
		sg=ti->ti_Data;
	else
		sg=(GetTagData(WA_Flags,NULL,tags)&WFLG_SIZEGADGET);

	if(ti=FindTagItem(WA_SizeBBottom,tags))
		sbb=ti->ti_Data;
	else
		sbb=(GetTagData(WA_Flags,NULL,tags)&WFLG_SIZEBBOTTOM);

	if(ti=FindTagItem(WA_SizeBRight,tags))
		sbr=ti->ti_Data;
	else
		sbr=(GetTagData(WA_Flags,NULL,tags)&WFLG_SIZEBRIGHT);

	if(im=(struct Image *)NewObject(NULL, SYSICLASS,
		SYSIA_DrawInfo, DrawInfo,
		SYSIA_Which, SIZEIMAGE,
		SYSIA_Size, (Scr->Flags & SCREENHIRES ? SYSISIZE_MEDRES : SYSISIZE_LOWRES),
		TAG_DONE))
	{
		sw=im->Width;
		sh=im->Height;
		DisposeObject((Object *)im);
	}
	else
	{
		sw=18;
		sh=10;
	}

	if(!bl)
	{
		if(sg && (!sbb) && (!sbr)) { (*offx)+=sw; (*offy)+=Scr->WBorBottom; }
		if(sg && (sbb) && (!sbr)) { (*offx)+=Scr->WBorRight; (*offy)+=sh; }
		if(sg && (!sbb) && (sbr)) { (*offx)+=sw; (*offy)+=Scr->WBorBottom; }
		if(sg && sbb && sbr) { (*offx)+=sw; (*offy)+=sh; }
		if((!sg) && (sbb) && (!sbr)) { (*offx)+=Scr->WBorRight; (*offy)+=sh; }
		if((!sg) && (!sbb) && (sbr)) { (*offx)+=sw; (*offy)+=Scr->WBorBottom; }
		if((!sg) && (sbb) && (sbr)) { (*offx)+=sw; (*offy)+=sh; }
	}
}
UWORD AdaptX(UWORD value)
{
	return((UWORD)(((FontX*value)+3)/7));
}

UWORD AdaptY(UWORD value)
{
	return((UWORD)(((FontY*value)+6)/13));
}

void CalcAdaptivity(UWORD width, UWORD height)
{
	Font = &Attr;
	Font->ta_Name = (STRPTR)Scr->RastPort.Font->tf_Message.mn_Node.ln_Name;
	Font->ta_YSize = FontY = Scr->RastPort.Font->tf_YSize;
	FontX = Scr->RastPort.Font->tf_XSize;

	if(width && height)
		if((AdaptX(width) > Scr->Width) || (AdaptY(height) > Scr->Height)) goto UseTopaz;
	return;

UseTopaz:
	Font->ta_Name = (STRPTR)"topaz.font";
	FontX = FontY = Font->ta_YSize = 8;
}

void FixGadgetTags(struct TagItem *tags)
{
	ULONG kind,a;
	UBYTE **labels;
	struct TagItem *ti;
	struct Node *node;

	kind=tags[0].ti_Tag;
	tags=&tags[1];

	if(kind!=TOOLIMAGE_KIND && kind!=DATATYPE_KIND) if(ti=FindTagItem(GA_Text,tags)) ti->ti_Data=(ULONG) GetCatString((APTR)ti->ti_Data);

	switch(kind)
	{
		case LISTVIEW_KIND:
			if(ti=FindTagItem(GTMX_Labels,tags))
				for(node=(struct Node *)ti->ti_Data;node->ln_Succ;node=node->ln_Succ)
					node->ln_Name=GetCatString((APTR)node->ln_Name);
			break;
		case MX_KIND:
			if(ti=FindTagItem(GTMX_Labels,tags))
				for(labels=(UBYTE **) ti->ti_Data,a=0;labels[a];a++) labels[a]=(UBYTE *) GetCatString((APTR)labels[a]);
			break;
		case NUMBER_KIND:
			if(ti=FindTagItem(GTNM_Format,tags)) ti->ti_Data=(ULONG) GetCatString((APTR)ti->ti_Data);
			break;
		case CYCLE_KIND:
			if(ti=FindTagItem(GTCY_Labels,tags))
				for(labels=(UBYTE **) ti->ti_Data,a=0;labels[a];a++) labels[a]=(UBYTE *) GetCatString((APTR)labels[a]);
			break;
		case SLIDER_KIND:
			if(ti=FindTagItem(GTSL_LevelFormat,tags)) ti->ti_Data=(ULONG) GetCatString((APTR)ti->ti_Data);
			break;
		case STRING_KIND:
			if(ti=FindTagItem(GTST_String,tags)) ti->ti_Data=(ULONG) GetCatString((APTR)ti->ti_Data);
			break;
		case TEXT_KIND:
			if(ti=FindTagItem(GTTX_Text,tags)) ti->ti_Data=(ULONG) GetCatString((APTR)ti->ti_Data);
			break;
	}
}

void FixWindowTags(struct TagItem *tags)
{
	struct TagItem *ti;

	if(ti=FindTagItem(WA_Title,tags)) ti->ti_Data=(ULONG) GetCatString((APTR)ti->ti_Data);
	if(ti=FindTagItem(WA_ScreenTitle,tags)) ti->ti_Data=(ULONG) GetCatString((APTR)ti->ti_Data);
}

void FixMenus(struct NewMenu *menu)
{
	ULONG a;

	for(a=0;menu[a].nm_Type!=NM_END;a++)
		if((menu[a].nm_Label!=NM_BARLABEL) && (menu[a].nm_Label))
		{
			menu[a].nm_CommKey=GetCatString(menu[a].nm_Label);
			menu[a].nm_Label=menu[a].nm_CommKey+2;
			if(menu[a].nm_CommKey[0]=='\0') menu[a].nm_CommKey=NULL;
		}
}

/* Screen functions */

UWORD SetupScreen(UBYTE Num)
{
	UWORD OffX,OffY;

	if(!(Scr=LockPubScreen(ScrPubName))) return GTBERR_OPENSCREEN;
	OffX=Scr->WBorLeft; OffY=Scr->RastPort.TxHeight+Scr->WBorTop+1;

	CalcAdaptivity(0,0);
	if(!(VisualInfo=GetVisualInfo(Scr,TAG_DONE))) return GTBERR_VISUALINFO;

	if(!(DrawInfo=GetScreenDrawInfo(Scr))) return GTBERR_SCRDRAWINFO;

	return GTBERR_OK;
}

void CloseDownScreen()
{
	if(DrawInfo) FreeScreenDrawInfo(Scr,DrawInfo); DrawInfo=NULL;
	if(VisualInfo) FreeVisualInfo(VisualInfo); VisualInfo=NULL;
	if(Scr) UnlockPubScreen(NULL,Scr); Scr=NULL;
}

int HandleIDCMP_Prefs()
{
	struct IntuiMessage *m;
	int (*func)();
	BOOL running = TRUE;

	while(m=GT_GetIMsg(PrefsWnd->UserPort))
	{
		CopyMem((APTR)m,(APTR)&PrefsMsg,sizeof(struct IntuiMessage));
		GT_ReplyIMsg(m);
		switch(PrefsMsg.Class)
		{
			case IDCMP_CLOSEWINDOW:
				running=FN_CloseWindow_Prefs();
				if(running > 1) return running;
				break;
			case IDCMP_GADGETUP:
			case IDCMP_GADGETDOWN:
				func = ( void * )(( struct Gadget * )PrefsMsg.IAddress )->UserData;
				running = func();
				if(running > 1) return running;
				break;
		}
	}
	return(running);
}

void Render_Prefs()
{
	UWORD OffX=PrefsWnd->BorderLeft, OffY=PrefsWnd->BorderTop;

	if(FindTagItem(WA_FontAdaptive,(struct TagItem *)PrefsWTags)) CalcAdaptivity(GetTagData(WA_Width,GetTagData(WA_InnerWidth,GetTagData(WA_RelWidth,0,(struct TagItem *)PrefsWTags),(struct TagItem *)PrefsWTags),(struct TagItem *)PrefsWTags),GetTagData(WA_Height,GetTagData(WA_InnerHeight,GetTagData(WA_RelHeight,0,(struct TagItem *)PrefsWTags),(struct TagItem *)PrefsWTags),(struct TagItem *)PrefsWTags)); else { FontX=7; FontY=13; }

	DrawBevelBox( PrefsWnd->RPort, AdaptX(8)+OffX, AdaptY(88)+OffY, AdaptX(257), AdaptY(2), GT_VisualInfo, VisualInfo, GTBB_FrameType, BBFT_BUTTON, GTBB_Recessed, TRUE, TAG_DONE);
}

UWORD OpenWindow_Prefs()
{
	struct Gadget *g;
	UWORD lc,tc;
	UWORD OffX,OffY;

	if(!(g=CreateContext(&PrefsGList))) return GTBERR_CREATECONTEXT;

	CalcLeftTop(&OffX,&OffY,(struct TagItem *)PrefsWTags);
	if(FindTagItem(WA_FontAdaptive,(struct TagItem *)PrefsWTags)) CalcAdaptivity(GetTagData(WA_Width,GetTagData(WA_InnerWidth,GetTagData(WA_RelWidth,0,(struct TagItem *)PrefsWTags),(struct TagItem *)PrefsWTags),(struct TagItem *)PrefsWTags),GetTagData(WA_Height,GetTagData(WA_InnerHeight,GetTagData(WA_RelHeight,0,(struct TagItem *)PrefsWTags),(struct TagItem *)PrefsWTags),(struct TagItem *)PrefsWTags)); else { FontX=7; FontY=13; }


	for(lc=0,tc=0;lc<CNT_Prefs;lc++)
	{
		if(!GadgetLocaleDone[WND_Prefs]) FixGadgetTags((struct TagItem *)&PrefsGTags[tc]);
		PrefsGadgets[lc]=g=CreateGadgetExA(OffX,OffY,0,0,g,(struct TagItem *) &PrefsGTags[tc]);
		tc+=2;
		while(PrefsGTags[tc]!=TAG_DONE) tc+=2;
		tc++;
		if(!(g)) return GTBERR_CREATEGADGET;
	}

	GadgetLocaleDone[WND_Prefs]=TRUE;

	if(!WindowLocaleDone[WND_Prefs]) FixWindowTags((struct TagItem *)PrefsWTags);
	WindowLocaleDone[WND_Prefs]=TRUE;

	if(!(PrefsWnd=OpenWindowTagsEx(
				WA_Gadgets,PrefsGList,
				WA_CustomScreen, Scr,
				TAG_MORE, PrefsWTags ))) return GTBERR_OPENWINDOW;

	GT_RefreshWindow(PrefsWnd,NULL);
	Render_Prefs();
	return GTBERR_OK;
}

void CloseWindow_Prefs()
{
	if(PrefsWnd) CloseWindowEx(PrefsWnd); PrefsWnd=NULL;
	if(PrefsGList)
	{
		FreeGadgets(PrefsGList);
		PrefsGList=NULL;
	}
}

